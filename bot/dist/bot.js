"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TelegramBot = void 0;
const node_telegram_bot_api_1 = __importDefault(require("node-telegram-bot-api"));
const start_handler_1 = require("./handlers/start.handler");
const help_handler_1 = require("./handlers/help.handler");
const login_handler_1 = require("./handlers/login.handler");
const payment_handler_1 = require("./handlers/payment.handler");
const catalog_handler_1 = require("./handlers/catalog.handler");
const my_movies_handler_1 = require("./handlers/my-movies.handler");
const payment_callback_handler_1 = require("./handlers/payment-callback.handler");
const security_service_1 = require("./services/security.service");
const notification_service_1 = require("./services/notification.service");
class TelegramBot {
    constructor(token) {
        this.token = token || process.env.TELEGRAM_BOT_TOKEN;
        if (!this.token) {
            throw new Error('TELEGRAM_BOT_TOKEN is required');
        }
        const botMode = process.env.BOT_MODE || 'webhook';
        const isPolling = botMode === 'polling';
        if (isPolling) {
            console.log('Bot starting in POLLING mode (development)');
            this.bot = new node_telegram_bot_api_1.default(this.token, {
                polling: true
            });
        }
        else {
            console.log('Bot starting in WEBHOOK mode (production)');
            this.bot = new node_telegram_bot_api_1.default(this.token, {
                polling: false,
                webHook: {
                    port: parseInt(process.env.BOT_PORT || '3003')
                }
            });
        }
        this.notificationService = new notification_service_1.NotificationService(this.bot);
        this.setupCommands();
        this.setupCallbacks();
    }
    setupCommands() {
        this.bot.onText(/\/start(.*)/, (msg, match) => (0, start_handler_1.startHandler)(this.bot, msg, match));
        this.bot.onText(/\/help/, (msg) => (0, help_handler_1.helpHandler)(this.bot, msg));
        this.bot.onText(/\/ajuda/, (msg) => (0, help_handler_1.helpHandler)(this.bot, msg));
        this.bot.onText(/\/login(.*)/, (msg, match) => (0, login_handler_1.loginHandler)(this.bot, msg, match));
        this.bot.onText(/\/catalogo/, (msg) => (0, catalog_handler_1.catalogHandler)(this.bot, msg));
        this.bot.onText(/\/catalog/, (msg) => (0, catalog_handler_1.catalogHandler)(this.bot, msg));
        this.bot.onText(/\/meus_filmes/, (msg) => (0, my_movies_handler_1.myMoviesHandler)(this.bot, msg));
        this.bot.onText(/\/my_movies/, (msg) => (0, my_movies_handler_1.myMoviesHandler)(this.bot, msg));
        this.bot.onText(/\/minhas-compras/, (msg) => this.showPurchasesHandler(this.bot, msg));
        this.bot.onText(/\/my-purchases/, (msg) => this.showPurchasesHandler(this.bot, msg));
        this.bot.onText(/\/pedir (.+)/, (msg, match) => this.handleMovieRequest(this.bot, msg, match));
        this.bot.onText(/\/buy_(.+)/, (msg, match) => (0, payment_handler_1.paymentHandler)(this.bot, msg, match));
    }
    setupCallbacks() {
        this.bot.on('callback_query', async (callbackQuery) => {
            const { data, message } = callbackQuery;
            const chatId = message?.chat.id;
            if (!chatId || !data)
                return;
            try {
                const [action, ...params] = data.split('_');
                if (data.startsWith('catalog_') || data.startsWith('movie_') || data.startsWith('purchase_') || data.startsWith('trailer_') || data.startsWith('favorite_') || data.startsWith('delivery_')) {
                    await (0, catalog_handler_1.handleCatalogCallback)(this.bot, callbackQuery);
                    return;
                }
                if (data.startsWith('help_')) {
                    await (0, help_handler_1.handleHelpCallback)(this.bot, callbackQuery);
                    return;
                }
                if (data.startsWith('download_') || data.startsWith('watch_') || data.startsWith('rate_') || data.startsWith('app_') || data === 'purchase_history' || data === 'my_movies') {
                    await (0, my_movies_handler_1.handleMyMoviesCallback)(this.bot, callbackQuery);
                    return;
                }
                if (data.startsWith('notifications_') || data.startsWith('flash_promo_') ||
                    data === 'disable_notifications' ||
                    data === 'disable_promotions' ||
                    data === 'enable_notifications') {
                    await this.notificationService.handleNotificationCallback(callbackQuery);
                    return;
                }
                if (data.startsWith('delivery_')) {
                    await this.handleDeliverySelection(chatId, data);
                    return;
                }
                if (data === 'my_purchases') {
                    await this.showPurchasesHandler(this.bot, message);
                    return;
                }
                if (data === 'main_menu') {
                    await this.showMainMenu(chatId);
                    return;
                }
                if (data.startsWith('pay_pix_')) {
                    const purchaseToken = data.replace('pay_pix_', '').replace('streaming_', '');
                    await (0, payment_callback_handler_1.handlePixPayment)(this.bot, callbackQuery, purchaseToken);
                    return;
                }
                if (data.startsWith('pay_card_')) {
                    const purchaseToken = data.replace('pay_card_', '').replace('streaming_', '');
                    await (0, payment_callback_handler_1.handleCardPayment)(this.bot, callbackQuery, purchaseToken);
                    return;
                }
                if (data.startsWith('check_payment_')) {
                    const purchaseId = data.replace('check_payment_', '');
                    await (0, payment_callback_handler_1.handleCheckPayment)(this.bot, callbackQuery, purchaseId);
                    return;
                }
                if (data.startsWith('cancel_payment_')) {
                    const purchaseId = data.replace('cancel_payment_', '');
                    await (0, payment_callback_handler_1.handleCancelPayment)(this.bot, callbackQuery, purchaseId);
                    return;
                }
                switch (action) {
                    case 'pay':
                        await this.handlePaymentMethod(chatId, params[0], params[1]);
                        break;
                    case 'cancel':
                        await this.handleCancelPurchase(chatId, params[0]);
                        break;
                    case 'buy':
                        await this.handlePurchase(chatId, params[0]);
                        break;
                    case 'watch':
                        await this.handleWatchCallback(callbackQuery);
                        break;
                    case 'download':
                        await this.handleDownload(chatId, params[0]);
                        break;
                    default:
                        console.log(`Unknown callback action: ${action}`);
                }
            }
            catch (error) {
                console.error('Error handling callback query:', error);
                await this.bot.sendMessage(chatId, '‚ùå Ocorreu um erro ao processar sua solicita√ß√£o. Tente novamente.');
            }
            await this.bot.answerCallbackQuery(callbackQuery.id);
        });
    }
    async handlePurchase(chatId, movieId) {
        await this.bot.sendMessage(chatId, `Iniciando compra do filme ${movieId}...`);
    }
    async handleWatch(chatId, movieId) {
        await this.bot.sendMessage(chatId, `Redirecionando para assistir filme ${movieId}...`);
    }
    async handleDownload(chatId, movieId) {
        await this.bot.sendMessage(chatId, `Preparando download do filme ${movieId}...`);
    }
    async handlePaymentMethod(chatId, method, purchaseToken) {
        if (method === 'pix') {
            await this.handlePixPayment(chatId, purchaseToken);
        }
        else if (method === 'card') {
            await this.handleCardPayment(chatId, purchaseToken);
        }
    }
    async handlePixPayment(chatId, purchaseToken) {
        const pixMessage = `üì± **Pagamento via PIX**

üî∏ **Chave PIX:** \`${process.env.PIX_KEY || 'pix@cinevision.com'}\`
üî∏ **Valor:** R$ (Ser√° atualizado automaticamente)

üìã **Instru√ß√µes:**
1. Copie a chave PIX acima
2. Abra seu app do banco
3. Fa√ßa o pagamento para a chave copiada
4. ‚è±Ô∏è O pagamento ser√° confirmado automaticamente em at√© 5 minutos

‚ùó **Importante:** N√£o altere o valor do PIX, pois isso pode atrasar a confirma√ß√£o.`;
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üì± Copiar Chave PIX', callback_data: `copy_pix_${purchaseToken}` }
                ],
                [
                    { text: '‚úÖ J√° Fiz o PIX', callback_data: `confirm_pix_${purchaseToken}` },
                    { text: '‚ùå Cancelar', callback_data: `cancel_${purchaseToken}` }
                ]
            ]
        };
        await this.bot.sendMessage(chatId, pixMessage, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    async handleCardPayment(chatId, purchaseToken) {
        const cardMessage = `üí≥ **Pagamento via Cart√£o**

üî∏ Em breve voc√™ ser√° redirecionado para o link de pagamento seguro
üî∏ Aceitamos todas as bandeiras: Visa, MasterCard, Elo, etc.
üî∏ Pagamento processado em at√© 2 minutos

üîí **Seguran√ßa garantida** - Utilizamos criptografia SSL`;
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üí≥ Pagar com Cart√£o', url: `${process.env.PAYMENT_GATEWAY_URL}/${purchaseToken}` }
                ],
                [
                    { text: '‚ùå Cancelar', callback_data: `cancel_${purchaseToken}` }
                ]
            ]
        };
        await this.bot.sendMessage(chatId, cardMessage, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    async handleCancelPurchase(chatId, purchaseToken) {
        await this.bot.sendMessage(chatId, '‚ùå **Compra cancelada**\n\nVoc√™ pode iniciar uma nova compra a qualquer momento atrav√©s do nosso site.', { parse_mode: 'Markdown' });
    }
    async sendMessage(chatId, text, options) {
        return this.bot.sendMessage(chatId, text, options);
    }
    async sendPhoto(chatId, photo, options) {
        return this.bot.sendPhoto(chatId, photo, options);
    }
    async sendDocument(chatId, document, options) {
        return this.bot.sendDocument(chatId, document, options);
    }
    stop() {
        this.bot.stopPolling();
        console.log('Telegram Bot stopped');
    }
    async showMainMenu(chatId) {
        const message = `üé¨ **CINE VISION** - Menu Principal

üçø O que voc√™ quer fazer?`;
        const keyboard = {
            inline_keyboard: [
                [
                    { text: 'üé¨ Ver Filmes', callback_data: 'catalog_menu' },
                    { text: 'üì± Meus Filmes', callback_data: 'my_movies' }
                ],
                [
                    { text: 'üÜò Ajuda', callback_data: 'help_menu' }
                ]
            ]
        };
        await this.bot.sendMessage(chatId, message, {
            parse_mode: 'Markdown',
            reply_markup: keyboard
        });
    }
    async handleDeliverySelection(chatId, data) {
        const parts = data.split('_');
        const deliveryType = parts[1];
        const movieId = parts[2] || 'unknown';
        if (deliveryType === 'telegram') {
            const message = `üí≥ **ESCOLHA COMO PAGAR**

üé¨ Filme selecionado
üí∞ R$ 19,90
üì¶ Download Telegram

Selecione o pagamento:`;
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üì± PIX (Instant√¢neo)', callback_data: `pay_pix_${movieId}` }
                    ],
                    [
                        { text: 'üí≥ Cart√£o', callback_data: `pay_card_${movieId}` }
                    ],
                    [
                        { text: '‚ùå Cancelar', callback_data: 'catalog_menu' }
                    ]
                ]
            };
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        }
        else if (deliveryType === 'streaming') {
            const message = `üí≥ **ESCOLHA COMO PAGAR**

üé¨ Filme selecionado
üí∞ R$ 19,90
üì¶ Assistir Online

Selecione o pagamento:`;
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: 'üì± PIX (Instant√¢neo)', callback_data: `pay_pix_streaming_${movieId}` }
                    ],
                    [
                        { text: 'üí≥ Cart√£o', callback_data: `pay_card_streaming_${movieId}` }
                    ],
                    [
                        { text: '‚ùå Cancelar', callback_data: 'catalog_menu' }
                    ]
                ]
            };
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        }
    }
    async showPurchasesHandler(bot, msg) {
        const chatId = msg.chat.id;
        const telegramId = msg.from?.id;
        try {
            const purchases = await security_service_1.SecurityService.makeAuthenticatedRequest('GET', `${process.env.BACKEND_URL}/api/purchases/user/${telegramId}`);
            if (!purchases || purchases.length === 0) {
                await bot.sendMessage(chatId, `üìã **MINHAS COMPRAS**

Voc√™ ainda n√£o fez nenhuma compra.

üé¨ Explore nosso cat√°logo e encontre filmes incr√≠veis!`, {
                    parse_mode: 'Markdown',
                    reply_markup: {
                        inline_keyboard: [
                            [{ text: 'üé¨ Ver Cat√°logo', callback_data: 'catalog_menu' }]
                        ]
                    }
                });
                return;
            }
            let message = `üìã **MINHAS COMPRAS**\n\n`;
            const keyboard = [];
            for (const purchase of purchases.slice(0, 5)) {
                const status = this.getStatusEmoji(purchase.status);
                const amount = (purchase.amount_cents / 100).toFixed(2);
                const date = new Date(purchase.created_at).toLocaleDateString('pt-BR');
                message += `${status} **${purchase.content.title}**\n`;
                message += `üí∞ R$ ${amount} | üìÖ ${date}\n`;
                message += `Status: ${this.getStatusText(purchase.status)}\n\n`;
                if (purchase.status === 'paid') {
                    keyboard.push([
                        { text: `üé¨ Assistir: ${purchase.content.title}`, callback_data: `watch_${purchase.id}` }
                    ]);
                }
            }
            keyboard.push([{ text: 'üé¨ Ver Cat√°logo', callback_data: 'catalog_menu' }]);
            await bot.sendMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: { inline_keyboard: keyboard }
            });
        }
        catch (error) {
            console.error('Error fetching purchases:', error);
            await bot.sendMessage(chatId, `‚ùå Erro ao buscar suas compras. Tente novamente mais tarde.`);
        }
    }
    async handleMovieRequest(bot, msg, match) {
        const chatId = msg.chat.id;
        const telegramId = msg.from?.id;
        const movieTitle = match?.[1]?.trim();
        if (!movieTitle) {
            await bot.sendMessage(chatId, `‚ùå Por favor, especifique o t√≠tulo do filme.\n\nExemplo: /pedir Vingadores Ultimato`);
            return;
        }
        try {
            const requestData = {
                title: movieTitle,
                telegram_id: telegramId,
                telegram_username: msg.from?.username,
                telegram_first_name: msg.from?.first_name
            };
            await security_service_1.SecurityService.makeAuthenticatedRequest('POST', `${process.env.BACKEND_URL}/api/requests`, requestData);
            await bot.sendMessage(chatId, `‚úÖ **Pedido Registrado!**

üé¨ **${movieTitle}**

Seu pedido foi registrado com sucesso! Nossa equipe ir√° analisar e, se poss√≠vel, adicionar este filme ao cat√°logo.

üìß Voc√™ ser√° notificado quando o filme estiver dispon√≠vel.

Obrigado pela sugest√£o! üôè`, {
                parse_mode: 'Markdown',
                reply_markup: {
                    inline_keyboard: [
                        [{ text: 'üé¨ Ver Cat√°logo', callback_data: 'catalog_menu' }]
                    ]
                }
            });
        }
        catch (error) {
            console.error('Error creating movie request:', error);
            await bot.sendMessage(chatId, `‚ùå Erro ao registrar seu pedido. Tente novamente mais tarde.`);
        }
    }
    getStatusEmoji(status) {
        switch (status) {
            case 'paid': return '‚úÖ';
            case 'pending': return '‚è≥';
            case 'failed': return '‚ùå';
            case 'cancelled': return 'üö´';
            default: return '‚ùì';
        }
    }
    getStatusText(status) {
        switch (status) {
            case 'paid': return 'Pago';
            case 'pending': return 'Aguardando pagamento';
            case 'failed': return 'Falhou';
            case 'cancelled': return 'Cancelado';
            default: return 'Desconhecido';
        }
    }
    async handleWatchCallback(callbackQuery) {
        const chatId = callbackQuery.message?.chat.id;
        const data = callbackQuery.data;
        if (!chatId || !data)
            return;
        const purchaseId = data.split('_')[1];
        try {
            const purchase = await security_service_1.SecurityService.makeAuthenticatedRequest('GET', `${process.env.BACKEND_URL}/api/purchases/${purchaseId}`);
            if (!purchase || purchase.status !== 'paid') {
                await this.bot.sendMessage(chatId, '‚ùå Filme n√£o encontrado ou pagamento pendente.');
                return;
            }
            const streamingUrl = `${process.env.STREAMING_URL}/watch/${purchase.content.id}?token=${purchase.access_token}`;
            const message = `üé¨ **${purchase.content.title}**

‚ú® Seu filme est√° pronto para assistir!

üîó Clique no bot√£o abaixo para come√ßar:`;
            const keyboard = {
                inline_keyboard: [
                    [
                        { text: '‚ñ∂Ô∏è Assistir Agora', url: streamingUrl }
                    ],
                    [
                        { text: 'üì± Baixar no Telegram', callback_data: `download_${purchaseId}` }
                    ],
                    [
                        { text: 'üîô Voltar', callback_data: 'my_movies' }
                    ]
                ]
            };
            await this.bot.sendMessage(chatId, message, {
                parse_mode: 'Markdown',
                reply_markup: keyboard
            });
        }
        catch (error) {
            console.error('Error handling watch callback:', error);
            await this.bot.sendMessage(chatId, '‚ùå Erro ao acessar o filme. Tente novamente.');
        }
    }
    getBot() {
        return this.bot;
    }
}
exports.TelegramBot = TelegramBot;
//# sourceMappingURL=bot.js.map