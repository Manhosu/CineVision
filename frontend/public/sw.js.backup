// Cine Vision Service Worker
const CACHE_NAME = 'cine-vision-v1';
const RUNTIME_CACHE = 'cine-vision-runtime';

// Files to cache on install
const PRECACHE_URLS = [
  '/',
  '/offline.html',
  '/_next/static/css/globals.css',
  '/favicon.ico',
  '/icons/icon-192x192.png',
  '/icons/icon-512x512.png'
];

// Install event - precache essential files
self.addEventListener('install', event => {
  console.log('[SW] Install event');

  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => {
        console.log('[SW] Precaching files');
        return cache.addAll(PRECACHE_URLS);
      })
      .then(() => self.skipWaiting())
      .catch(error => console.error('[SW] Precache failed:', error))
  );
});

// Activate event - clean up old caches
self.addEventListener('activate', event => {
  console.log('[SW] Activate event');

  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (cacheName !== CACHE_NAME && cacheName !== RUNTIME_CACHE) {
              console.log('[SW] Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch event - implement cache strategies
self.addEventListener('fetch', event => {
  const { request } = event;
  const url = new URL(request.url);

  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }

  // Skip Chrome extensions
  if (url.protocol === 'chrome-extension:') {
    return;
  }

  // Handle API requests (network first)
  if (url.pathname.startsWith('/api/') || url.hostname !== self.location.hostname) {
    event.respondWith(
      networkFirst(request)
    );
    return;
  }

  // Handle images (cache first)
  if (request.destination === 'image') {
    event.respondWith(
      cacheFirst(request)
    );
    return;
  }

  // Handle video/audio (network only)
  if (request.destination === 'video' || request.destination === 'audio') {
    event.respondWith(
      fetch(request)
    );
    return;
  }

  // Handle pages and static assets (stale while revalidate)
  event.respondWith(
    staleWhileRevalidate(request)
  );
});

// Cache Strategies

// Network First - Good for API calls
async function networkFirst(request) {
  try {
    const networkResponse = await fetch(request);

    // Cache successful responses
    if (networkResponse.ok) {
      const cache = await caches.open(RUNTIME_CACHE);
      cache.put(request, networkResponse.clone());
    }

    return networkResponse;
  } catch (error) {
    console.log('[SW] Network failed, trying cache:', request.url);
    const cachedResponse = await caches.match(request);

    if (cachedResponse) {
      return cachedResponse;
    }

    // Return offline page for navigation requests
    if (request.mode === 'navigate') {
      return caches.match('/offline.html');
    }

    throw error;
  }
}

// Cache First - Good for images and static assets
async function cacheFirst(request) {
  const cachedResponse = await caches.match(request);

  if (cachedResponse) {
    return cachedResponse;
  }

  try {
    const networkResponse = await fetch(request);

    if (networkResponse.ok) {
      const cache = await caches.open(RUNTIME_CACHE);
      cache.put(request, networkResponse.clone());
    }

    return networkResponse;
  } catch (error) {
    console.log('[SW] Failed to fetch:', request.url);
    throw error;
  }
}

// Stale While Revalidate - Good for pages and frequently updated content
async function staleWhileRevalidate(request) {
  const cache = await caches.open(RUNTIME_CACHE);
  const cachedResponse = await cache.match(request);

  const fetchPromise = fetch(request).then(networkResponse => {
    if (networkResponse.ok) {
      cache.put(request, networkResponse.clone());
    }
    return networkResponse;
  }).catch(error => {
    console.log('[SW] Network failed:', request.url);
    return null;
  });

  // Return cached version immediately, update cache in background
  if (cachedResponse) {
    fetchPromise; // Don't await, let it run in background
    return cachedResponse;
  }

  // No cached version, wait for network
  const networkResponse = await fetchPromise;

  if (networkResponse) {
    return networkResponse;
  }

  // Network failed and no cache, return offline page for navigation
  if (request.mode === 'navigate') {
    return caches.match('/offline.html');
  }

  throw new Error('No cached response and network failed');
}

// Handle background sync for offline actions
self.addEventListener('sync', event => {
  console.log('[SW] Background sync:', event.tag);

  if (event.tag === 'movie-purchase') {
    event.waitUntil(
      syncMoviePurchases()
    );
  }
});

// Sync movie purchases when online
async function syncMoviePurchases() {
  try {
    // Get pending purchases from IndexedDB
    const pendingPurchases = await getPendingPurchases();

    for (const purchase of pendingPurchases) {
      try {
        const response = await fetch('/api/purchases/initiate', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(purchase)
        });

        if (response.ok) {
          // Remove from pending purchases
          await removePendingPurchase(purchase.id);

          // Notify user
          self.registration.showNotification('Compra processada!', {
            body: `Sua compra de "${purchase.movieTitle}" foi processada com sucesso.`,
            icon: '/icons/icon-192x192.png',
            badge: '/icons/badge.png',
            tag: 'purchase-success',
            data: { purchaseId: purchase.id }
          });
        }
      } catch (error) {
        console.error('[SW] Failed to sync purchase:', error);
      }
    }
  } catch (error) {
    console.error('[SW] Background sync failed:', error);
  }
}

// Handle push notifications
self.addEventListener('push', event => {
  console.log('[SW] Push notification received');

  if (!event.data) {
    return;
  }

  const data = event.data.json();

  const options = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge.png',
    tag: data.tag || 'notification',
    requireInteraction: data.requireInteraction || false,
    actions: data.actions || [],
    data: data.data || {}
  };

  event.waitUntil(
    self.registration.showNotification(data.title, options)
  );
});

// Handle notification clicks
self.addEventListener('notificationclick', event => {
  console.log('[SW] Notification clicked:', event.notification.tag);

  event.notification.close();

  const { data } = event.notification;

  // Handle different notification types
  switch (event.notification.tag) {
    case 'purchase-success':
      event.waitUntil(
        clients.openWindow(`/movies/${data.movieId}`)
      );
      break;

    case 'new-release':
      event.waitUntil(
        clients.openWindow('/releases')
      );
      break;

    default:
      event.waitUntil(
        clients.openWindow('/')
      );
  }
});

// Utility functions for IndexedDB (simplified)
async function getPendingPurchases() {
  // This would normally use IndexedDB
  // For now, return empty array
  return [];
}

async function removePendingPurchase(id) {
  // This would normally remove from IndexedDB
  console.log('[SW] Would remove purchase:', id);
}

// Handle message events from the main thread
self.addEventListener('message', event => {
  console.log('[SW] Message received:', event.data);

  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data && event.data.type === 'CACHE_MOVIE') {
    const { movieId, imageUrl } = event.data;

    // Preload movie images
    event.waitUntil(
      caches.open(RUNTIME_CACHE)
        .then(cache => cache.add(imageUrl))
        .catch(error => console.error('[SW] Failed to cache movie image:', error))
    );
  }
});

console.log('[SW] Service Worker loaded');